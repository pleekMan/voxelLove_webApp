<html>

<head>
    <meta charset=utf-8>
    <title>Voxel Love webApp</title>

    <link rel="stylesheet" href="css/style.css">
    <script src="js/libs/three.js"></script>
    <script src="js/libs/OrbitControls.js"></script>




</head>
<body>

    


    <div class="row">
        <div class="column" style="background-color:#aaa;">
          <p>TextDiv</p>
        </div>
        <div class="column" style="background-color:#ccc">
          <!-- <p>viewPort Div</p> -->
          <div id="viewport"></div>
        </div>
      </div>
    
    <!-- SHADER - VERTEX -->
    <script type="x-shader/x-vertex" id="vertexShader">
        varying vec3 vColor;
        void main() {
            // position (vec3) is the vertex input attribute, in model space
            
            vColor = color;

            vec4 finalPos = vec4(position.x * (1.0 - position.y), position.y, position.z, 1.0);
            gl_Position = projectionMatrix * modelViewMatrix * finalPos;
        }
    </script>

    <!-- SHADER - FRAGMENT  -->
    <script type="x-shader/x-fragment" id="fragmentShader">
        uniform sampler2D texture;
        varying vec3 vColor;
        void main() {
            gl_FragColor = vec4( vColor, 1.0 );
            //gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
        }
    </script>

    <!-- MAIN THREE.JS CODE   -->
    <script>

        var scene, camera, light;
        var renderer;

        var voxelCube; // type: Points. [A Object3D class for displaying meshes as points (with gl_Points)]
        var vertexDensity = 100.0;

        setup();
        animate();

        function setup(){
            // EVENT LISTENERS
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener("keypress", onKeyPressed, false);
            window.addEventListener("load", onWinLoad, false);

            // DEV TOOLS
            //var stats;
            //initStatsPanel();

            var viewport = document.getElementById("viewport");

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
            viewport.appendChild(renderer.domElement);

            // SETUP - BEGIN
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75,viewport.clientWidth / viewport.clientHeight, 0.1, 1000);
            light = new THREE.AmbientLight(0x404040); // soft white light
            scene.add(light);


            // CAM ORBITER
            var camOrbit = new THREE.OrbitControls(camera, renderer.domElement);
            camera.position.set(2,2,2);
            camOrbit.update(); // CALL AFTER MANUALLY SETTING THE CAMERA


            // SETUP - END

            scene.add(new THREE.AxesHelper(1));

            setupVoxelCube();
        }



        function draw() {

        }

        function animate() {

            draw();

            requestAnimationFrame(animate);
            renderer.render(scene, camera);

        }



        // MY FUNCTIONS

        function setupVoxelCube(){

            var positions = [];
			var colors = [];
			var sizes = [];

            var geometry = new THREE.BufferGeometry();
            var color = new THREE.Color();


            var separation = 1.0 / vertexDensity;
            //var separation = 1.0 / vertexDensity;
            for (var z = 0; z < vertexDensity; z++) {
                for (var y = 0; y < vertexDensity; y++) {
                    for (var x = 0; x < vertexDensity; x++) {

                        //var arrayPos = x + (y*RES_X) + (z*RES_X*RES_Y);
                        positions.push(x * separation, y * separation, z * separation);

                        color.setRGB(x / vertexDensity, y / vertexDensity, z / vertexDensity);
                        colors.push(color.r, color.g, color.b);

                        sizes.push(2);

                    }
                }
            }


            geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
			geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
			geometry.addAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1 ));//.setDynamic( true ) );

            //material = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors});

            var shaderMaterial = new THREE.ShaderMaterial( {
				//uniforms: uniforms,
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
				//blending: THREE.AdditiveBlending,
				depthTest: false,
				transparent: true,
				vertexColors: true
			} );

            voxelCube = new THREE.Points(geometry, shaderMaterial);

            scene.add(voxelCube);
        }


        // EVENTS
        function onMouseDown(event) {

            event.preventDefault();

            switch (event.which) {
                case 1: // left mouse click
                    break;

                case 3: // right mouse click
                    break;
            }

        }

        function onKeyPressed(key) {
            //console.log("Event Input key: " + key);

            var keyCode = key.keyCode;
            console.log("KeyCode: " + keyCode);
            var keyChar = String.fromCharCode(key.keyCode);
            console.log("KeyChar: " + keyChar);


            if (keyChar === " ") {

            }
        }

        // OTHER FUNCTIONS


        function onWinLoad() {

        }

    </script>
</body>

</html>
<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <script src="js/libs/three.js"></script>
    <script src="js/libs/OrbitControls.js"></script>

    <!-- CODEMIRROR -->
    <script src="js/libs/codemirror-5.43.0/lib/codemirror.js"></script>
    <link rel="stylesheet" href="js/libs/codemirror-5.43.0/lib/codemirror.css">
    <link rel="stylesheet" href="js/libs/codemirror-5.43.0/theme/darcula.css">
    <script src="js/libs/codemirror-5.43.0/mode/javascript/javascript.js"></script>


    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
        integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">


    <link rel="stylesheet" href="css/styles.css">

    <title>Voxel Love :: Editor</title>
</head>

<body>
    <nav class="navbar navbar-light">
        <a class="navbar-brand" id="headerTitle" href="#">
            <img src="images/voxelLove_50px.png" width="50" height="50" class="d-inline-block align-top"
                alt="Voxel Love">
            Voxel Love
        </a>
    </nav>

    <div class="container-fluid" id="middle">
        <div class="row">
            <div class="col textContainer">
                <p>Voxel Love is a playground for vertex shaders. The vertices are packed inside a cube, within a normalized space.</br>
                    The 3 RGB sliders over the viewport enter the shader as the variable <code> controls.xyz </code></br>
                    <code>vertexColor</code> gets passed onto the fragment shader, to modify each vertex color.</br>
                    <code>position.xyz</code> is the vertex position in local space.
                </p>
            </div>
            <div class="col" id="controls">

                <div class="row" id="controlsContainer">
                    <div class="flex-column" id="sliderContainer">
                        <input type="range" min="1" max="100" value="50" class="slider" id="controlA" oninput="updateShaderControls(0,this.value)">
                        <label id="controlALabel">0.01</label>
                        <input type="range" min="1" max="100" value="50" class="slider" id="controlB" oninput="updateShaderControls(1,this.value)">
                        <label id="controlBLabel">-0.34</label>
                        <input type="range" min="1" max="100" value="50" class="slider" id="controlC" oninput="updateShaderControls(2,this.value)">
                        <label id="controlCLabel">1.00</label>
                    </div>
                    <div class="flex-column" id="sliderContainer2">
                        <input class="form-control-sm" id="controlDensity" placeholder="100" onchange="updateVertexDensity(this.value)">
                        <small class="form-text text-muted" id="controlDensityLabel" style="color:orangered;">Vertex
                            Density<sup>3</sup></small>
                    </div>
                    <div class="flex-column" id="sliderContainer2">
                        <button type="button" class="btn btn-info btn-sm" id="controlResetCamera" onclick="resetCameraPosition()">Reset Camera</button>
                        <div id="checkBoxContainer">
                            <input type="checkbox" class="custom-control-input" id="axisCheckBox" checked onclick="toggleAxisGizmos(this)">
                            <label class="custom-control-label" for="axisCheckBox">Show Axis</label>
                        </div>
                    </div>
                </div>


            </div>
        </div>
    </div>

    <!-- EDITOR + VIEWPORT -->

    <div class="container-fluid" id="codeViewport">
        <div class="row">
            <div class="col" id="codeColumn">
                <textarea id="codeText" rows="40" cols="80"></textarea>
            </div>
            <div class="col-6" id="viewportColumn">
                <div id="viewport"></div>
            </div>
        </div>
    </div>

    <div class="container-fluid">
        <div id="compileButtonContainer">
            <button type="button" class="btn btn-info btn-sm" id="compileButton" onclick="sendCode()">Compile</button>
            <label id="compileButtonLabel" for="compileButton"><small>Ctrl/Cmd + R on Editor</small></label>
        </div>
        <div class="alert alert-danger" id="errorDiv" role="alert">
                Error Messages
            </div>
        <div class="col textContainer" id="footer">
            <p><a href="http://www.pleek.net" target="_blank"> <code>www.pleek.net</code></a> &nbsp;&nbsp;&nbsp; Tools used: <a href="https://threejs.org/" target="_blank">THREE.js</a>, <a href="https://codemirror.net/" target="_blank">CodeMirror</a>, <a href="https://getbootstrap.com/" target="_blank">Bootstrap</a>.</p>
            </div>
    </div>

    <!-- CODE MIRROR SCRIPT -->
    <script>

        var myCodeMirror = CodeMirror.fromTextArea(document.getElementById("codeText"), {
            value: "Starting Text\nLine Two\nLine3",
            mode: "javascript",
            theme: "darcula",
            lineNumbers: true
        });
        //myCodeMirror.setSize(900, 500);

        myCodeMirror.setOption("extraKeys", {
            "Cmd-R": function (cm) {
                sendCode();
                // var spaces = Array(cm.getOption("indentUnit") + 1).join("--");
                // cm.replaceSelection(spaces);
            },
            "Ctrl-R": function (cm) {
                sendCode();
            }
        });


            //myCodeMirror.setValue("Start-up Text"); // --> onWinLoad function (bototm)
            // myCodeMirror.refresh();
    </script>

    <script>
        function sendCode() {
            //var codeText = document.getElementById("codeText").value;
            var codeString = myCodeMirror.getValue();
            //console.log(codeString);

            shaderInputCode = codeString;
            updateShader(shaderInputCode);

        }
    </script>





    <!-- SHADER - VERTEX -->
    <script type="x-shader/x-vertex" id="vertexShader">
const float PI = 3.14159265358;
const float TWO_PI = 6.28318530718;
const float HALF_PI = 1.57079632679;

uniform vec3 controls;
uniform float time;
varying vec4 vertexColor;

void main() {

    float wavyX = position.x * sin(position.y * TWO_PI + (time * (0.1 * controls.x) ) ); // DRAG THE RED SLIDER
    float offsetY = position.y + controls.y;
    vec4 finalPos = vec4(wavyX, offsetY, position.z, 1.0);

    gl_Position = projectionMatrix * modelViewMatrix * finalPos;
    vertexColor = vec4(color,1.0);

}
    </script>

    <!-- SHADER - FRAGMENT  -->
    <script type="x-shader/x-fragment" id="fragmentShader">
varying vec4 vertexColor;
void main() {
    gl_FragColor = vertexColor;
}
    </script>



    <!-- MAIN THREE.JS CODE   -->

    <script>

        var scene, camera, camOrbit, light, axisGizmo;
        var renderer;
        var glContext;

        var voxelCube; // type: Points. [A Object3D class for displaying meshes as points (with gl_Points)]
        var vertexDensity = 50.0;
        var shaderMaterial;

        var isShaderCorrected = false;
        var shaderInputCode;
        var previousShaderCode;

        var shaderUniforms;
        var frameCount = 0;
        var shaderControls = new THREE.Vector3();
        var controlElementA = document.getElementById("controlA");
        var controlElementB = document.getElementById("controlB");
        var controlElementC = document.getElementById("controlC");

        setup();
        animate();

        function setup() {
            // EVENT LISTENERS
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener("keypress", onKeyPressed, false);
            window.addEventListener("load", onWinLoad, false);

            //window.addEventListener("error", onWinError, false);


            // DEV TOOLS
            //var stats;
            //initStatsPanel();

            var viewport = document.getElementById("viewport");

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
            viewport.appendChild(renderer.domElement);

            // SETUP - BEGIN
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, viewport.clientWidth / viewport.clientHeight, 0.1, 1000);
            light = new THREE.AmbientLight(0x404040); // soft white light
            glContext = renderer.getContext(); // FOR LATTER SHADER ERROR HANDLING

            scene.add(light);


            // CAM ORBITER
            camOrbit = new THREE.OrbitControls(camera, renderer.domElement);
            camera.position.set(2, 2, 2);
            camOrbit.enablePan = false; // WORK-AROUND FOR NOT PANNING THE CAMERA WHEN MOVING AROUND THE EDITOR WITH ARROW KEYS
            camOrbit.update(); // CALL AFTER MANUALLY SETTING THE CAMERA


            // SETUP - END
            axisGizmo = new THREE.AxesHelper(1); 
            scene.add(axisGizmo);

            setupVoxelCube();

            // GUI SETUP ---------------

            updateShaderControls(0,50);
            updateShaderControls(1,50);
            updateShaderControls(2,50);

            document.getElementById("controlDensity").value = vertexDensity;

        }


        function animate() {

            shaderUniforms.time.value = frameCount;

            requestAnimationFrame(animate);
            renderer.render(scene, camera);


            if (!isShaderCorrected)checkShaderError();

            frameCount++;

        }



        // MY FUNCTIONS

        function setupVoxelCube() {

            /*
            var positions = [];
            var colors = [];
            var sizes = [];

            var geometry = new THREE.BufferGeometry();
            var color = new THREE.Color();


            var separation = 1.0 / vertexDensity;
            //var separation = 1.0 / vertexDensity;
            for (var z = 0; z < vertexDensity; z++) {
                for (var y = 0; y < vertexDensity; y++) {
                    for (var x = 0; x < vertexDensity; x++) {

                        //var arrayPos = x + (y*RES_X) + (z*RES_X*RES_Y);
                        positions.push(x * separation, y * separation, z * separation);

                        color.setRGB(x / vertexDensity, y / vertexDensity, z / vertexDensity);
                        colors.push(color.r, color.g, color.b);

                        sizes.push(2);

                    }
                }
            }


            geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.addAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));//.setDynamic( true ) );

            */

            //material = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors});

            voxelCube = new THREE.Points();

            setupVoxelVertices(50);

            shaderUniforms = {
                "time": { value: frameCount },
                "controls": { value: shaderControls }
            }

            shaderMaterial = new THREE.ShaderMaterial({
                uniforms: shaderUniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                //blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                vertexColors: true
            });

            shaderInputCode = document.getElementById('vertexShader').textContent;
            previousShaderCode = shaderInputCode;

            voxelCube.material = shaderMaterial;
            //voxelCube = new THREE.Points(geometry, shaderMaterial);
            scene.add(voxelCube);
        }

        function setupVoxelVertices(inVertexDensity){

            vertexDensity = inVertexDensity;

            var positions = [];
            var colors = [];
            //var sizes = [];

            var geometry = new THREE.BufferGeometry();
            var color = new THREE.Color();


            var separation = 1.0 / vertexDensity;

            for (var z = 0; z < vertexDensity; z++) {
                for (var y = 0; y < vertexDensity; y++) {
                    for (var x = 0; x < vertexDensity; x++) {

                        //var arrayPos = x + (y*RES_X) + (z*RES_X*RES_Y);
                        positions.push(x * separation, y * separation, z * separation);

                        color.setRGB(x / vertexDensity, y / vertexDensity, z / vertexDensity);
                        colors.push(color.r, color.g, color.b);

                        //sizes.push(2);

                    }
                }
            }


            geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            //geometry.addAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));//.setDynamic( true ) );

            // NOT CLEARING ANYTHING.. JUST RELYING ON JS GARBAGE COLLECTOR HERE...  :S
            voxelCube.geometry = geometry;
        }

        function updateShader(codeString) {
            isShaderCorrected = false;
            shaderMaterial.vertexShader = codeString;
            voxelCube.material.needsUpdate = true;
        }

        function checkShaderError() {
            var infoString = glContext.getShaderInfoLog(shaderMaterial.program.vertexShader);
            var sliced = infoString.slice(0, 5);

            if (sliced === "ERROR") {
                console.log("I AIN'T TRUSTIN' THIS SHADER..!!");
                // isShaderCorrect = false;
                updateShader(previousShaderCode);
                isShaderCorrected = true;
                updateErrorMessage(false, infoString);
                return false;
            } else {
                console.log("SHADER'S ALRIGHT, LET HIM THROUGH...");
                previousShaderCode = shaderInputCode;
                isShaderCorrected = true;
                updateErrorMessage(true, "");
                return true;
            }
        }

        function updateErrorMessage(status, message) {

            var errorDiv = document.getElementById("errorDiv");
            //errorDiv.style.transition = "all 0.5s";

            if (status) {
                errorDiv.innerText = "";
                errorDiv.style.backgroundColor = "black";
                errorDiv.style.color = "black";
            } else {
                errorDiv.innerText = reFormatErrorMessage(message);
                errorDiv.style.backgroundColor = "#ab0010";
                errorDiv.style.color = "white";
            }

        }

        function reFormatErrorMessage(message) {
            //ERROR: 0: 52: '=' : cannot convert from 'const mediump float' to 'highp 4-component vector of float'
            //ERROR: 0: 53: 'finalPos' : undeclared identifier
            var lines = message.split("\n");
            var finalMessage = "";

            const editorlineNumberingOffset = 42;

            for (let i = 0; i < lines.length - 1; i++) {
                var elements = lines[i].split(":");

                var lineNumber = parseInt(elements[2]) - editorlineNumberingOffset;
                var finalLine = "At Line: " + lineNumber + "\u00A0".repeat(5) + elements[3] + " | " + elements[4] + "\n";
                finalMessage += finalLine;
            }

            return finalMessage;

        }

        // CONTROLS CALLBACKS --------------
        function updateShaderControls(channel, value){
            value = (value - 50) / 50; // map to -1 -> 1
            shaderControls.setComponent(channel, value);

            updateControlsLabel(shaderControls);
            //console.log(shaderControls);
        }

        function updateControlsLabel(shaderControls){
            document.getElementById("controlALabel").innerText = shaderControls.x;
            document.getElementById("controlBLabel").innerText = shaderControls.y;
            document.getElementById("controlCLabel").innerText = shaderControls.z;
        }

        function updateVertexDensity(newVertexCount){
            setupVoxelVertices(newVertexCount > 5 ? newVertexCount : 5);
            document.getElementById("controlDensity").value = vertexDensity;


        }

        function resetCameraPosition(){
            camera.position.set(2, 2, 2);
            camOrbit.update(); // CALL AFTER MANUALLY SETTING THE CAMERA

        }

        function toggleAxisGizmos(object){
            axisGizmo.visible = object.checked;
        }



        // EVENTS
        function onMouseDown(event) {

            // event.preventDefault();

            switch (event.which) {
                case 1: // left mouse click
                    break;

                case 3: // right mouse click
                    break;
            }

        }

        function onKeyPressed(key) {
            //console.log("Event Input key: " + key);

            //var keyCode = key.keyCode;
            //console.log("KeyCode: " + keyCode);
            //var keyChar = String.fromCharCode(key.keyCode);
            //console.log("KeyChar: " + keyChar);


            // if (keyChar === " ") {

            // }
        }

        // OTHER FUNCTIONS


        function onWinLoad() {
            myCodeMirror.setValue(document.getElementById("vertexShader").textContent);
            //myCodeMirror.setSize(document.getElementById("codeColumn").getAttribute("width"), 500);
            //myCodeMirror.refresh();
        }


    </script>

    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--     
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"
        integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
        crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js"
        integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy"
        crossorigin="anonymous"></script> -->
</body>

</html>
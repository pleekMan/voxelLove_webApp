<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <script src="js/libs/three.js"></script>
    <script src="js/libs/OrbitControls.js"></script>

    <!-- CODEMIRROR -->
    <script src="js/libs/codemirror-5.43.0/lib/codemirror.js"></script>
    <link rel="stylesheet" href="js/libs/codemirror-5.43.0/lib/codemirror.css">
    <link rel="stylesheet" href="js/libs/codemirror-5.43.0/theme/darcula.css">
    <script src="js/libs/codemirror-5.43.0/mode/javascript/javascript.js"></script>


    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
        integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">


    <link rel="stylesheet" href="css/styles.css">

    <title>Voxel Love :: Editor</title>
</head>

<body>
    <nav class="navbar navbar-light">
        <a class="navbar-brand" id="headerTitle" href="#">
            <img src="images/voxelLove_50px.png" width="50" height="50" class="d-inline-block align-top"
                alt="Voxel Love">
            Voxel Love
        </a>
    </nav>

    <div class="container-fluid" id="middle">
        <div class="row" >
            <div class="col" id="textContainer">
                TEXT
            </div>
            <div class="col" id="controls">

                <div class="row" id="controlsContainer">
                    <div class="col" id="slidercontainer">
                        <div>
                            <input type="range" min="1" max="100" value="50" class="slider" id="controlA">
                        </div>
                        <div>
                            <input type="range" min="1" max="100" value="50" class="slider" id="controlB">
                        </div>
                        <div>
                            <input type="range" min="1" max="100" value="50" class="slider" id="controlC">
                        </div>
                    </div>

                    <div class="col">
                    </div>
                </div>

                <div id="controlsLabelContainer">

                </div>
            </div>
        </div>
    </div>

    <!-- EDITOR + VIEWPORT -->

    <div class="container-fluid" id="codeViewport">
        <div class="row">
            <div class="col" id="codeColumn">
                <textarea id="codeText" rows="40" cols="80"></textarea>
            </div>
            <div class="col-6" id="viewportColumn">
                <div id="viewport"></div>
            </div>
        </div>
    </div>

    <div class="container-fluid">
        <button onclick="sendCode()">Compile</button>
        <div id="errorDiv">Vertices are feeling fine</div>
    </div>

    <!-- CODE MIRROR SCRIPT -->
    <script>

        var myCodeMirror = CodeMirror.fromTextArea(document.getElementById("codeText"), {
            value: "Starting Text\nLine Two\nLine3",
            mode: "javascript",
            theme: "darcula",
            lineNumbers: true
        });
        //myCodeMirror.setSize(900, 500);

        myCodeMirror.setOption("extraKeys", {
            "Cmd-R": function (cm) {
                sendCode();
                // var spaces = Array(cm.getOption("indentUnit") + 1).join("--");
                // cm.replaceSelection(spaces);
            },
            "Ctrl-R": function (cm) {
                sendCode();
            }
        });


            //myCodeMirror.setValue("Start-up Text"); // --> onWinLoad function (bototm)
            // myCodeMirror.refresh();
    </script>

    <script>
        function sendCode() {
            //var codeText = document.getElementById("codeText").value;
            var codeString = myCodeMirror.getValue();
            //console.log(codeString);

            shaderInputCode = codeString;
            updateShader(shaderInputCode);

        }
    </script>





    <!-- SHADER - VERTEX -->
    <script type="x-shader/x-vertex" id="vertexShader">
varying vec3 vColor;
uniform float time;
uniform vec3 controls;
void main() {
    // position (vec3) is the vertex input attribute, in model space
    
    vColor = color;

    vec4 finalPos = vec4(position.x * sin(position.y + (time * (0.1 * controls.x    ))), position.y + controls.y, position.z, 1.0);
    gl_Position = projectionMatrix * modelViewMatrix * finalPos;
}
    </script>

    <!-- SHADER - FRAGMENT  -->
    <script type="x-shader/x-fragment" id="fragmentShader">
varying vec3 vColor;
void main() {
    gl_FragColor = vec4( vColor, 1.0 );
}
    </script>



    <!-- MAIN THREE.JS CODE   -->

    <script>

        var scene, camera, light;
        var renderer;
        var glContext;

        var voxelCube; // type: Points. [A Object3D class for displaying meshes as points (with gl_Points)]
        var vertexDensity = 100.0;
        var shaderMaterial;

        var isShaderCorrected = false;
        var shaderInputCode;
        var previousShaderCode;

        var shaderUniforms;
        var frameCount = 0;
        var shaderControls = new THREE.Vector3();
        var controlElementA = document.getElementById("controlA");
        var controlElementB = document.getElementById("controlB");
        var controlElementC = document.getElementById("controlC");

        setup();
        animate();

        function setup() {
            // EVENT LISTENERS
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener("keypress", onKeyPressed, false);
            window.addEventListener("load", onWinLoad, false);

            //window.addEventListener("error", onWinError, false);


            // DEV TOOLS
            //var stats;
            //initStatsPanel();

            var viewport = document.getElementById("viewport");

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
            viewport.appendChild(renderer.domElement);

            // SETUP - BEGIN
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, viewport.clientWidth / viewport.clientHeight, 0.1, 1000);
            light = new THREE.AmbientLight(0x404040); // soft white light
            glContext = renderer.getContext(); // FOR LATTER SHADER ERROR HANDLING

            scene.add(light);


            // CAM ORBITER
            var camOrbit = new THREE.OrbitControls(camera, renderer.domElement);
            camera.position.set(2, 2, 2);
            camOrbit.enablePan = false; // WORK-AROUND FOR NOT PANNING THE CAMERA WHEN MOVING AROUND THE EDITOR WITH ARROW KEYS
            camOrbit.update(); // CALL AFTER MANUALLY SETTING THE CAMERA


            // SETUP - END

            scene.add(new THREE.AxesHelper(1));


            setupVoxelCube();

        }


        function animate() {

            shaderUniforms.time.value = frameCount;

            var mappedControls = new THREE.Vector3(controlElementA.value / 50 - 1, controlElementB.value / 50 - 1, controlElementC.value / 50 - 1);
            shaderControls.set(mappedControls.x, mappedControls.y, mappedControls.z); // update them with sliderGUIs

            //requestAnimationFrame(animate);
            renderer.render(scene, camera);

            if (!isShaderCorrected) {
                var correct = checkShaderError();

                if (correct) {
                    //document.getElementByClass("columnLeft").setAttribute("class", "columnLeft correct");
                    document.getElementById("errorDiv").style.backgroundColor = "green";
                } else {
                    //document.getElementByClass("columnLeft").setAttribute("class", "columnLeft error");
                    document.getElementById("errorDiv").style.backgroundColor = "red";
                }
            }

            frameCount++;

        }



        // MY FUNCTIONS

        function setupVoxelCube() {

            var positions = [];
            var colors = [];
            var sizes = [];

            var geometry = new THREE.BufferGeometry();
            var color = new THREE.Color();


            var separation = 1.0 / vertexDensity;
            //var separation = 1.0 / vertexDensity;
            for (var z = 0; z < vertexDensity; z++) {
                for (var y = 0; y < vertexDensity; y++) {
                    for (var x = 0; x < vertexDensity; x++) {

                        //var arrayPos = x + (y*RES_X) + (z*RES_X*RES_Y);
                        positions.push(x * separation, y * separation, z * separation);

                        color.setRGB(x / vertexDensity, y / vertexDensity, z / vertexDensity);
                        colors.push(color.r, color.g, color.b);

                        sizes.push(2);

                    }
                }
            }


            geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.addAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));//.setDynamic( true ) );

            //material = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors});


            shaderUniforms = {
                "time": { value: frameCount },
                "controls": { value: shaderControls }
            }

            shaderMaterial = new THREE.ShaderMaterial({
                uniforms: shaderUniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                //blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                vertexColors: true
            });

            shaderInputCode = document.getElementById('vertexShader').textContent;
            previousShaderCode = shaderInputCode;

            voxelCube = new THREE.Points(geometry, shaderMaterial);
            scene.add(voxelCube);
        }

        function updateShader(codeString) {
            isShaderCorrected = false;
            shaderMaterial.vertexShader = codeString;
            voxelCube.material.needsUpdate = true;
        }

        function checkShaderError() {
            var infoString = glContext.getShaderInfoLog(shaderMaterial.program.vertexShader);
            var sliced = infoString.slice(0, 5);

            if (sliced === "ERROR") {
                console.log("I AIN'T TRUSTIN' THIS SHADER..!!");
                // isShaderCorrect = false;
                updateShader(previousShaderCode);
                isShaderCorrected = true;
                updateErrorMessage(false, infoString);
                return false;
            } else {
                console.log("SHADER'S ALRIGHT, LET HIM THROUGH...");
                previousShaderCode = shaderInputCode;
                isShaderCorrected = true;
                updateErrorMessage(true, "");
                return true;
            }
        }

        function updateErrorMessage(status, message) {

            var errorDiv = document.getElementById("errorDiv");


            if (status) {
                errorDiv.innerText = "Vertices are chilling, bro!!"
            } else {
                errorDiv.innerText = reFormatErrorMessage(message);
            }

        }

        function reFormatErrorMessage(message) {
            //ERROR: 0: 52: '=' : cannot convert from 'const mediump float' to 'highp 4-component vector of float'
            //ERROR: 0: 53: 'finalPos' : undeclared identifier
            var lines = message.split("\n");
            var finalMessage = "";

            const editorlineNumberingOffset = 42;

            for (let i = 0; i < lines.length - 1; i++) {
                var elements = lines[i].split(":");

                var lineNumber = parseInt(elements[2]) - editorlineNumberingOffset;
                var finalLine = "At Line: " + lineNumber + " || " + elements[3] + " || " + elements[4] + "\n";
                finalMessage += finalLine;
            }

            return finalMessage;

        }



        // EVENTS
        function onMouseDown(event) {

            // event.preventDefault();

            switch (event.which) {
                case 1: // left mouse click
                    break;

                case 3: // right mouse click
                    break;
            }

        }

        function onKeyPressed(key) {
            //console.log("Event Input key: " + key);

            //var keyCode = key.keyCode;
            //console.log("KeyCode: " + keyCode);
            //var keyChar = String.fromCharCode(key.keyCode);
            //console.log("KeyChar: " + keyChar);


            // if (keyChar === " ") {

            // }
        }

        // OTHER FUNCTIONS


        function onWinLoad() {
            myCodeMirror.setValue(document.getElementById("vertexShader").textContent);
            //myCodeMirror.setSize(document.getElementById("codeColumn").getAttribute("width"), 500);
            //myCodeMirror.refresh();
        }


    </script>

    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"
        integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
        crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js"
        integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy"
        crossorigin="anonymous"></script>
</body>

</html>
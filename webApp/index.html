<html>

<head>
    <meta charset=utf-8>
    <title>Voxel Love webApp</title>

    <!-- STYLE + THREEjs STUFF -->
    <link rel="stylesheet" href="css/style.css">
    <script src="js/libs/three.js"></script>
    <script src="js/libs/OrbitControls.js"></script>

    <!-- CODEMIRROR -->
    <script src="js/libs/codemirror-5.43.0/lib/codemirror.js"></script>
    <link rel="stylesheet" href="js/libs/codemirror-5.43.0/lib/codemirror.css">
    <link rel="stylesheet" href="js/libs/codemirror-5.43.0/theme/darcula.css">
    <script src="js/libs/codemirror-5.43.0/mode/javascript/javascript.js"></script>


    
    <!-- <script>
        var myCodeMirror = CodeMirror(document.body);
    </script> -->
    


</head>
<body>
    
    <!-- HTML DOM - BEGIN -->
    <div class="row">
        <div class="column" style="background-color:#aaa;">
            <textarea id="codeText" rows="40" cols="80"></textarea>
            <button onclick="sendCode()">Compile</button>
            <div id="errorDiv">Vertices are feeling fine</div>
        </div>
        <div class="column" style="background-color:#ccc">
          <div id="viewport"></div>
        </div>
    </div>

    <!-- HTML DOM - END -->

    <!-- HTML SCRIPTS BEGIN -->

    <script>


        // CODE MIRROR SCRIPT
 
        var myCodeMirror = CodeMirror.fromTextArea(document.getElementById("codeText"), {
            value: "Starting Text\nLine Two\nLine3",
            mode:  "javascript",
            theme: "darcula",
            lineNumbers: true
        });
            
        //myCodeMirror.setValue("Start-up Text"); // --> onWinLoad function (bototm)
        // myCodeMirror.refresh();
    </script>


    <script>
        function sendCode(){
            //var codeText = document.getElementById("codeText").value;
            var codeString = myCodeMirror.getValue();
            //console.log(codeString);

            shaderInputCode = codeString;
            updateShader(shaderInputCode);
            
        }
    </script>

    <!-- HTML SCRIPTS END -->

    
    <!-- SHADER - VERTEX -->
    <script type="x-shader/x-vertex" id="vertexShader">
varying vec3 vColor;
void main() {
    // position (vec3) is the vertex input attribute, in model space
    
    vColor = color;

    vec4 finalPos = vec4(position.x * (1.0 - position.y), position.y, position.z, 1.0);
    gl_Position = projectionMatrix * modelViewMatrix * finalPos;
}
    </script>

    <!-- SHADER - FRAGMENT  -->
    <script type="x-shader/x-fragment" id="fragmentShader">
uniform sampler2D texture;
varying vec3 vColor;
void main() {
    gl_FragColor = vec4( vColor, 1.0 );
    //gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
}
    </script>

    <!-- MAIN THREE.JS CODE   -->
    <script>

        var scene, camera, light;
        var renderer;
        var glContext;

        var voxelCube; // type: Points. [A Object3D class for displaying meshes as points (with gl_Points)]
        var vertexDensity = 100.0;
        var shaderMaterial;

        var shaderChanged = false;
        var shaderInputCode;
        var previousShaderCode;

        setup();
        animate();

        function setup(){
            // EVENT LISTENERS
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener("keypress", onKeyPressed, false);
            window.addEventListener("load", onWinLoad, false);
            //window.addEventListener("error", onWinError, false);


            // DEV TOOLS
            //var stats;
            //initStatsPanel();

            var viewport = document.getElementById("viewport");

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
            viewport.appendChild(renderer.domElement);

            // SETUP - BEGIN
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75,viewport.clientWidth / viewport.clientHeight, 0.1, 1000);
            light = new THREE.AmbientLight(0x404040); // soft white light
            glContext = renderer.getContext(); // FOR LATTER SHADER ERROR HANDLING

            scene.add(light);


            // CAM ORBITER
            var camOrbit = new THREE.OrbitControls(camera, renderer.domElement);
            camera.position.set(2,2,2);
            camOrbit.enablePan = false; // WORK-AROUND FOR NOT PANNING THE CAMERA WHEN MOVING AROUND THE EDITOR WITH ARROW KEYS
            camOrbit.update(); // CALL AFTER MANUALLY SETTING THE CAMERA


            // SETUP - END

            scene.add(new THREE.AxesHelper(1));

            setupVoxelCube();

        }



        function draw() {

        }

        function animate() {

            draw();

            requestAnimationFrame(animate);

            renderer.render(scene, camera);

            if(shaderChanged){
                checkShaderError();
            }

        }



        // MY FUNCTIONS

        function setupVoxelCube(){

            var positions = [];
			var colors = [];
			var sizes = [];

            var geometry = new THREE.BufferGeometry();
            var color = new THREE.Color();


            var separation = 1.0 / vertexDensity;
            //var separation = 1.0 / vertexDensity;
            for (var z = 0; z < vertexDensity; z++) {
                for (var y = 0; y < vertexDensity; y++) {
                    for (var x = 0; x < vertexDensity; x++) {

                        //var arrayPos = x + (y*RES_X) + (z*RES_X*RES_Y);
                        positions.push(x * separation, y * separation, z * separation);

                        color.setRGB(x / vertexDensity, y / vertexDensity, z / vertexDensity);
                        colors.push(color.r, color.g, color.b);

                        sizes.push(2);

                    }
                }
            }


            geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
			geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
			geometry.addAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1 ));//.setDynamic( true ) );

            //material = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors});

            shaderMaterial = new THREE.ShaderMaterial( {
				//uniforms: uniforms,
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
				//blending: THREE.AdditiveBlending,
				depthTest: false,
				transparent: true,
				vertexColors: true
            } );
            
            shaderInputCode = document.getElementById( 'vertexShader' ).textContent;
            previousShaderCode = shaderInputCode;

            voxelCube = new THREE.Points(geometry, shaderMaterial);
            scene.add(voxelCube);
        }

        function updateShader(codeString){
            shaderMaterial.vertexShader = codeString;
            voxelCube.material.needsUpdate = true;
            shaderChanged = true;
        }

        function checkShaderError(){
            var infoString = glContext.getShaderInfoLog(shaderMaterial.program.vertexShader);
            var sliced = infoString.slice(0,5); 
            if (sliced === "ERROR" ) {
                console.log("I AIN'T TRUSTIN' THIS SHADER..!!");
                updateShader(previousShaderCode);
                updateErrorMessage(false, infoString);
            } else {
                console.log("SHADER'S ALRIGHT, LET HIM THROUGH...");
                previousShaderCode = shaderInputCode;
                updateErrorMessage(true,"");
            }
            shaderChanged = false;
        }

        function updateErrorMessage(status, message){
            
            var errorDiv = document.getElementById("errorDiv");
            if (status) {
                errorDiv.innerText = "Vertices are chilling, bro!!"
            } else {
                var text = "Vertices are Freaking out...!!\n" + message;
                errorDiv.innerText = text;

            }

        }


        // EVENTS
        function onMouseDown(event) {

            // event.preventDefault();

            switch (event.which) {
                case 1: // left mouse click
                    break;

                case 3: // right mouse click
                    break;
            }

        }

        function onKeyPressed(key) {            
            //console.log("Event Input key: " + key);

            //var keyCode = key.keyCode;
            //console.log("KeyCode: " + keyCode);
            //var keyChar = String.fromCharCode(key.keyCode);
            //console.log("KeyChar: " + keyChar);


            // if (keyChar === " ") {

            // }
        }

        // OTHER FUNCTIONS


        function onWinLoad() {
            myCodeMirror.setValue(document.getElementById("vertexShader").textContent);
        }

        function onWinError(event){
            console.log("WINDOW ERROR");
        }



    </script>




    
</body>

</html>
var shaderPool = [
	{
		name: "Twist",
		controlsInitial: [0.5, 0.2, 0],
		code: [
			"// TWIST",
			"// controls.x => Twist Amount",
			"// controls.y => Object Rotation",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"const float HALF_PI = 1.57079632679;",
			"",
			"uniform vec3 controls;",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"",
			"mat4 rotateY(float angle){",
			"	float c = cos(angle);",
			"	float s = sin(angle);",
			"    return mat4(",
			"        vec4(c,0.,-s,0),",
			"        vec4(0.,1.,0.,0.),",
			"        vec4(s,0.,c,0.),",
			"        vec4(0.,0.,0.,1.));",
			"}",
			"",
			"void main() {",
			"",
			"  vec4 vCentered = (vec4(position,1.0) * 2.) - vec4(1.);",
			"",
			"	float offsetY = position.y + (time * controls.y);",
			"	float angleMult = controls.x * 5.;",
			"	vec4 twisted = rotateY((offsetY * angleMult) * PI) * vCentered;",
			"",
			"    gl_Position = projectionMatrix * modelViewMatrix * twisted;",
			"    vertexColor = vec4(color,0.15);",
			"",
			"} ",
		]
	},
	{
		name: "Wave",
		controlsInitial: [0.5, 0, 0],
		code: [
			"// Wave :: Vertical Sine wave",
			"// controls.x => Wave Speed",
			"// controls.y => Move Vertically",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"",
			"uniform vec3 controls;",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"",
			"void main() {",
			"",
			"	float wavyX = position.x * sin(position.y * TWO_PI + (time * controls.x ) ); // DRAG THE RED SLIDER",
			"	float offsetY = position.y + controls.y; // DRAG THE GREEN SLIDER",
			"	vec4 finalPos = vec4(wavyX, offsetY, position.z, 1.0);",
			"",
			"	gl_Position = projectionMatrix * modelViewMatrix * finalPos;",
			"	vertexColor = vec4(color,1.0);",
			"",
			"}"
		]

	},
	{
		name: "Empty Cube",
		controlsInitial: [0, 0, 0],
		code: [
			"// EMPTY CUBE",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"const float HALF_PI = 1.57079632679;",
			"",
			"uniform vec3 controls;",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"",
			"void main(){",
			"",
			"  vec4 finalPosition = vec4(position, 1.0);",
			"  gl_Position = projectionMatrix * modelViewMatrix * finalPosition;",
			"  vertexColor = vec4(color,1.0);",
			"}"
		]
	},
	{
		name: "Moebius",
		controlsInitial: [0, 0, 0.5],
		code: [
			"// INFINITY MOEBIUS",
			"// controls.y => Travel along surface",
			"// controls.z => Scale",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"const float HALF_PI = 1.57079632679;",
			"",
			"uniform vec3 controls;",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"",
			"mat4 scale(vec3 factor){",
			"  return mat4(",
			"    vec4(factor.x,0.,0.,0.),",
			"    vec4(0.,factor.y,0.,0.),",
			"    vec4(0.,0.,factor.z,0.),",
			"    vec4(0.,0.,0.,1.)",
			"  );",
			"}",
			"",
			"mat4 rotateY(float angle){",
			"	float c = cos(angle);",
			"	float s = sin(angle);",
			"    return mat4(",
			"        vec4(c,0.,-s,0),",
			"        vec4(0.,1.,0.,0.),",
			"        vec4(s,0.,c,0.),",
			"        vec4(0.,0.,0.,1.));",
			"}",
			"",
			"void main(){",
			"",
			"  vec4 movingUV = vec4(fract(position.x ), fract(position.y + controls.y), 1., 1.);",
			"  vec3 toSphereRange = vec3(movingUV.x * (TWO_PI), movingUV.y * (TWO_PI), movingUV.z * TWO_PI);",
			"",
			"  vec4 spherized = vec4(1);",
			"  spherized.x =  cos(toSphereRange.x) * sin(toSphereRange.y);",
			"  spherized.y = sin(toSphereRange.y) * cos(toSphereRange.y);",
			"  spherized.z = cos(toSphereRange.x);",
			"",
			"  spherized = rotateY(time * 0.1) * spherized;",
			"  vec4 scaled = scale(vec3(controls.z * 2.)) * spherized;",
			"",
			"  gl_Position = projectionMatrix * modelViewMatrix * scaled;",
			"  vertexColor = vec4(color,1.0);",
			"}"
		]
	}
]




